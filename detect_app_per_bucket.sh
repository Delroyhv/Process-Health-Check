#!/bin/bash
#
# ========================================================================
# Copyright (c) by Hitachi, 2024. All rights reserved.
# ========================================================================
#
# This script detects S3 apps that use the HCP for Cloud Scale system.
#
####################################################################
# Input parameters:
DEFAULT_PARTITION_RANGE="partitions_ranges.all.txt"
DEFAULT_BUCKETS_MAP_FILE="buckets_names.txt"
partition_range=${1:-"$DEFAULT_PARTITION_RANGE"} # input partition range file
bucket_names_uuids=${2:-"$DEFAULT_BUCKETS_MAP_FILE"} # buckets names and uuids mapping
OUTPUT_FILE=${3:-"app_per_bucket.txt"}

TEMP_BUCKETS_UUID_FILE="buckets.${partition_range}.tmp"

function usage() {
    thisfilename=$(basename "$0")

    echo "\
This script parses a partition range file to detect S3 apps for each bucket.
The partition range file is generated by super_parse_partition_map.sh script.

Usage: detect_app_per_bucket.sh [<partition_range_file> [<bucket_names_uuids> [<output_file>]]]
e.g. detect_app_per_bucket.sh partitions_ranges.all.txt buckets_names.txt

$thisfilename :
   <partition_range_file>    (optional)  partition range file
         default: ${DEFAULT_PARTITION_RANGE}
   <bucket_names_uuids>      (optional) file with bucket's names and uuids mapping
         default: ${DEFAULT_BUCKETS_MAP_FILE}
   <output_file>             (optional) output file
         default: ${OUTPUT_FILE}"
}

if [[ "$1" == "-h" ]]; then
    usage
    exit
fi

TOOLDIR=$(dirname "$0")
APP_LIB_FILE=${4:-"${TOOLDIR}/detect_app_lib.txt"} # File with apps definitions/signatures - overrides the internal definitions

#####################
# App definitions
#
declare -A apps=(
    ["Veeam/Archive"]="Veeam VBR - Capacity Tier"
    ["Veeam/Backup/"]="Veeam VBR - Backup"
    ["Veeam/Store/"]="Veeam (Store?)"
    ["Veeam/Backup365/"]="Veeam 365"
    ["/d/I_"]="Weka (HCSF)"
    ["/CV_"]="Commvault"
    ["/commvault"]="Commvault"
    ["netbackup"]="Netbackup"
    ["fake/"]="Grafana Loki"
)

# A message about app definitions/signatures file - it displayed at the end
APP_LIB_MSG=""

function set_app_lib() {
  APP_LIB="$1"
  while IFS= read -r app_def; do
    # Set app definition
    if ! [[ "${app_def:0:1}" == "#" || "${app_def}" == "" || "${app_def}" =~ ^[[:space:]]+$ ]]; then
        app_signature=$(echo "$app_def" | awk -F'"' '{print $2}')
        app_name=$(echo "$app_def" | awk -F'"' '{print $4}')
        apps[${app_signature}]="$app_name"
        # echo "Saving '$app_name' with '$app_signature'"
    fi
  done < ${APP_LIB}
}

if [[ -f ${APP_LIB_FILE} ]]; then
    set_app_lib ${APP_LIB_FILE}
    APP_LIB_MSG="Using apps signatures from ${APP_LIB_FILE} file."
else
    APP_LIB_MSG="Using internal apps signatures; ${APP_LIB_FILE} NOT FOUND."
fi


####################################################
function progress() {
   echo "$1" >&2
}

#####
# Logging to ${OUTPUT_FILE}
#
log_init="false"
function log() {
    if [[ "${log_init}" == "false" ]] ; then
        if [[ -f "${OUTPUT_FILE}" ]]; then
            rm -f "${OUTPUT_FILE}"
        fi
        log_init="true"
    fi
    echo "$1" | tee -a "${OUTPUT_FILE}"
}

#####
#
# Add spaces to a string $1 to be of $2 length
function add_spaces() {
    mystring="$1"
    (( max = ${2:?add_spaces: missing length argument} ))
    nlen=$(echo "$mystring" | wc -c)
    if [[ "$nlen" -le "$max" ]]; then
        ((nspaces=max-nlen+1))
        spaces=$(printf '%*s' "$nspaces" "")
        mystring+="$spaces"
    fi
    echo "$mystring"
}

# compare two value and return greater
function max() {
    max=$1
    if [[ "$max" -lt "$2" ]]; then
        ((max=$2))
    fi
	echo "$max"
}

####
#
function detect_apps() {
    map="$1"
    bucket="$2"
    detected=0
    apps_lines=""

    for signature in "${!apps[@]}" ; do
        num_partitions=$(echo "$map" | grep -i "$signature" | wc -l)
        if [[ ! "${num_partitions}" == "0" ]]; then
            ((detected++))
            apps_lines+="${apps[$signature]} : ${num_partitions}\n"
        fi
    done

    if [[ "$detected" == "0" ]]; then
        num_partitions=$(echo "$map" | wc -l)
        apps_lines+="Unknown app : ${num_partitions}\n"
    fi

    echo -ne "${apps_lines}"
}

############################################
# Start processing
# 

if [[ ! -f "${partition_range}" ]]; then
    progress "ERROR: FILE NOT FOUND: ${partition_range}"
    exit
fi


declare -A buckets_array

max_name=1
if [[ -f "${bucket_names_uuids}" ]]; then
    while IFS= read -r bucket_line; do
        bucket_name=$(echo "${bucket_line}" | awk -F= '{print $1}')
        bucket_uuid=$(echo "${bucket_line}" | awk -F= '{print $2}')
        buckets_array["${bucket_uuid}"]="${bucket_name}"
        # echo "${bucket_name}=${bucket_uuid}"
        name_len=$(echo "$bucket_name" | wc -c)
        if [[ "$max_name" -lt "$name_len" ]]; then
            ((max_name=name_len))
        fi
    done < "${bucket_names_uuids}"
    progress "Used ${bucket_names_uuids} file for bucket uuid->name mapping."
fi


# Detect known S3 apps
progress "Scan ${partition_range} file"
buckets="buckets.${partition_range}"
cat ${partition_range} | awk -F: '{print $2}' | awk NF | sort | uniq | tr -d " " > "${TEMP_BUCKETS_UUID_FILE}"
num_buckets=$(cat ${TEMP_BUCKETS_UUID_FILE} | wc -l)

bucket_title="bucket"
total_title="partitions"

nlen=$(echo "$bucket_title" | wc -c)
max_name=$(max $max_name $nlen)
bucket_title=$(add_spaces "$bucket_title" $max_name) # add spaces to $bucket_title to be aligned with a longest bucket name
total_title_len=$(echo "$total_title" | wc -c)

log "##: ${bucket_title} :             uuid                     : ${total_title} : signature"

count=0
total_partitions=0
while IFS= read -r bucket_uuid; do
    ((count++))
    bucket_map=$(cat ${partition_range} | awk -FEND: '{print $1}' | grep "$bucket_uuid") 

    if [[ "${buckets_array["${bucket_uuid}"]}" == "" ]]; then
        bucket_name="$(add_spaces "-" $max_name)"
    else 
        bucket_name="$(add_spaces "${buckets_array["${bucket_uuid}"]}" $max_name)"
    fi


    apps_lines=$(detect_apps "${bucket_map}" "${bucket_uuid}")
    apps_in_bucket=0
    while IFS= read -r apps_entry; do
        ((apps_in_bucket++))
        app_name="$(echo "$apps_entry" | awk -F: '{print $1}')"
        num_partitions="$(echo "$apps_entry" | awk -F: '{print $2}')"
        count_str="$(add_spaces "${count}" 2)"  # align with 2 spaces '##' in a title line
        num_partitions_str="$(add_spaces "$num_partitions" $total_title_len)" # align with spaces
        log "$count_str: $bucket_name : $bucket_uuid : ${num_partitions_str} : ${app_name}"
        ((total_partitions+=num_partitions))
    done <<< "$apps_lines"

    if [[ "${apps_in_bucket}" -gt "1" ]]; then
        log "#### WARNING: ${apps_in_bucket} apps sharing the same bucket ${buckets_array["${bucket_uuid}"]} (${bucket_uuid})" 
    fi

    apps_array=()

done < "${TEMP_BUCKETS_UUID_FILE}"
log "Buckets: ${num_buckets}, total partitions: ${total_partitions}"

rm -f "${TEMP_BUCKETS_UUID_FILE}"
progress "Generated ${OUTPUT_FILE} file (${num_buckets} buckets, ${total_partitions} partitions)."

progress "${APP_LIB_MSG}"