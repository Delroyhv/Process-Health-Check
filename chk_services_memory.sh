#!/usr/bin/env bash
#
# ========================================================================
# Copyright (c) by Hitachi, 2024. All rights reserved.
# ========================================================================
#
# chk_services_memory.sh v1.8.38
#
# It validates the services' memory configuration on HCP-CS system.
#
# memcheck.conf format per service:
#   ServiceName  128_min  128_max  256_min  256_max
#
# Node profile selection (based on MemTotal from meminfo, in kB):
#   - If node memory (GB) >= 192 -> use 256_min / 256_max (if present, else fallback to 128)
#   - Else                       -> use 128_min / 128_max
#
# Only services that are actually running (listed in hcpcs_services_info.log)
# are validated. If a service is not in that list, it is silently skipped.
#
# Additionally prints:
#   - TOTAL SERVICES MEMORY (MB/GB)
#   - ESTIMATED OS/OTHER MEMORY (MB/GB)
#
##

_script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC1091
. "${_script_dir}/gsc_core.sh"

_chktools_dir="${_script_dir}"
_default_dir_name="."
_default_output_file="health_report_service_memory.log"
_default_input_file_short_services="services.json"
_default_input_file_short_node="systeminfo_proc-meminfo"
_default_node_memory="128"
_default_skip_parse="false"
_default_forced_node_mem="false"
_default_tools_dir="${_chktools_dir}"

_other_memory=30 # GB for OS, Docker and Foundry services (for sanity/critical check)

_skip_parse=${_default_skip_parse}
_forced_node_mem=${_default_forced_node_mem}
_mem_config_required_file="${_chktools_dir}/memcheck.conf"
_services_parsed_memconfig_file_suffix="productinfo_services.log"

_output_file=${_default_output_file}
_input_file_service=""
_input_file_node=""
_input_file_short_services=${_default_input_file_short_services}
_input_file_short_node=${_default_input_file_short_node}
_node_memory=${_default_node_memory}
_log_dir=${_default_dir_name}
_tools_dir=${_default_tools_dir}

# Running services info file (generated by parse_instances_info.sh)
_default_services_info_short="hcpcs_services_info.log"
_input_file_short_servicesinfo="${_default_services_info_short}"

# List of active (running) services populated from hcpcs_services_info.log
_active_services=()

################################

usage() {
    local _this_filename
    _this_filename=$(basename "$0")

    echo "\
This script analyzes the service's memory configuration.

${_this_filename} -f <input-file> -d <dir-name> -s <input-file-shortname> -o <output-file>

${_this_filename} :
   -f <input_file_services>     file with memory configuration for services
                                if this option is specified, -d and -s options are ignored

   -F <input_file_node>         file with node's memory settings
                                if this option is specified, -d and -S options are ignored

   -o <output_file>             output parsed file name (default: ${_default_output_file})

   -d <dir-name>                directory name to search for input files with short names
                                default: current directory

   -s <input-file-short-services>   short name of input services's memory file to search in <dir-name>
                                    default: ${_default_input_file_short_services}

   -S <input-file-short-node>   short name of input node's memory file to search in <dir-name>
                                default: ${_default_input_file_short_node}

   -t <tools_dir>               directory with tools/scripts
                                default: ${_default_tools_dir}

   -m <node-memory-GB>          Node memory size in GB (overwrites value in ${_default_input_file_short_node} file)
                                default: ${_default_node_memory}

   -k                           skip parsing raw service file, use previously parsed file

   -I <services-info-short>     short name of HCP-CS services info file
                                (default: ${_default_services_info_short})
"
}


##############################
#
# Check the input parameters:
#
getOptions() {
    local _opt
    while getopts "f:F:d:s:S:o:t:m:I:kvh" _opt; do
        case ${_opt} in
            f)  _input_file_service=${OPTARG} ;;
            F)  _input_file_node=${OPTARG} ;;
            d)  _log_dir=${OPTARG} ;;
            s)  _input_file_short_services=${OPTARG} ;;
            S)  _input_file_short_node=${OPTARG} ;;
            v)  _verbose="true" ; _debug=1 ;;
            o)  _output_file=${OPTARG} ;;
            t)  _tools_dir=${OPTARG} ;;
            m)  _node_memory=${OPTARG}
                _forced_node_mem="true" ;;
            k)  _skip_parse="true" ;;
            I)  _input_file_short_servicesinfo=${OPTARG} ;;
            *)  usage
                exit 0 ;;
        esac
    done
}


############################

getOptions "$@"


#######
# Spinner stub (disabled to avoid '\r' in piped/teed output)
spinner() { :; }

#################
# Load active running services from hcpcs_services_info.log
#
load_active_services() {
    local _search_root="."
    local _short="${_input_file_short_servicesinfo}"

    local _info_file
    _info_file=$(gsc_find_file "${_search_root}" "${_short}")
    if [[ -z "${_info_file}" || ! -f "${_info_file}" ]]; then
        # No info file – treat all services as active (no filtering)
        return
    fi

    local _svc
    while IFS= read -r _svc; do
        _active_services+=("${_svc}")
    done < <(awk -F'[)]|:' '/^[0-9]+\)/ { gsub(/^[ \t]+|[ \t]+$/,"",$2); print $2 }' "${_info_file}")
}

#################
# Check if a service is active (running)
#
# If _active_services is empty (no info file found), everything is considered active.
is_service_active() {
    local _svc="$1"
    if [[ "${#_active_services[@]}" -eq 0 ]]; then
        return 0
    fi
    local _s
    for _s in "${_active_services[@]}"; do
        if [[ "${_s}" == "${_svc}" ]]; then
            return 0
        fi
    done
    return 1
}

##################### START #############

_err=0
_heap_ok_count=0
_heap_mismatch_count=0
_heap_skipped_count=0

gsc_loga "== CHECKING SERVICE'S MEMORY CONFIG =="

_services_parsed_memconfig_file=${_log_dir}/${_services_parsed_memconfig_file_suffix}

if [[ "${_forced_node_mem}" != "true" ]]; then
    # Find service config file in the collected package by its short name
    if [[ -n "${_input_file_service}" ]]; then
        _services_memconfig_file="${_input_file_service}"
    else
        _services_memconfig_file="$(gsc_find_file "${_log_dir}" "${_input_file_short_services}")"
    fi
    if [[ "${_services_memconfig_file}" == "" ]]; then
        gsc_loga "ERROR: CANNOT FIND FILE WITH ${_input_file_short_services} suffix in ${_log_dir} directory."
        exit 1
    fi

    if [[ ! -f ${_services_memconfig_file} ]]; then
        gsc_loga "ERROR: CANNOT FIND ${_services_memconfig_file} in ${_log_dir} directory."
        exit 1
    fi

    if [[ "$(head -n 1 "${_services_memconfig_file}" | grep "#")" != "" ]]; then
        _services_memconfig_json=$(tail -n +2 "${_services_memconfig_file}")
    else
        _services_memconfig_json=$(cat "${_services_memconfig_file}")
    fi

    if [[ "${_services_memconfig_json}" == "" || "$(gsc_is_json "${_services_memconfig_json}")" == "false" ]]; then
        gsc_loga "ERROR: INVALID SERVICE INPUT FILE: ${_services_memconfig_file} - NOT EXPECTED FORMAT"
        exit 1
    fi
fi

if [[ ! -f ${_mem_config_required_file} ]]; then
    gsc_loga "INTERNAL ERROR: cannot find ${_mem_config_required_file} file in ${_chktools_dir} directory."
    exit 1
fi

if [[ -f ${_output_file} ]]; then
    mv "${_output_file}" "${_output_file}.bak"
fi


if [[ "${_forced_node_mem}" != "true" ]]; then

    if [[ -n "${_input_file_node}" ]]; then
        _meminfo_file="${_input_file_node}"
    else
        _meminfo_file=$(find "${_log_dir}" | grep "${_input_file_short_node}" | head -n 1)
    fi
    if [[ "${_meminfo_file}" == "" ]] ; then
        gsc_loga "WARNING: CANNOT FIND FILE WITH ${_input_file_short_node} suffix in ${_log_dir} directory."
    elif [[ ! -f ${_meminfo_file} ]]; then
        gsc_loga "ERROR: CANNOT FIND ${_meminfo_file} file in ${_log_dir} directory."
    else

        # parse ${_meminfo_file}
        _mem=$(awk '/MemTotal/ { print $2 }' "${_meminfo_file}")  # kB

        if [[ "$(gsc_is_empty "${_mem}")" == "true" ]]; then
            gsc_loga "INTERNAL ERROR: FAILED TO PARSE ${_meminfo_file} file"
        fi

        # Thresholds in kB (GB * 1024 * 1024)
        _gb_120=$((120 * 1024 * 1024))
        _gb_180=$((180 * 1024 * 1024))
        _gb_200=$((200 * 1024 * 1024))
        _gb_250=$((250 * 1024 * 1024))
        _gb_265=$((265 * 1024 * 1024))
        _gb_300=$((300 * 1024 * 1024))
        _gb_500=$((500 * 1024 * 1024))

        # Classify node memory based on MemTotal (kB)
        if  (( _mem > _gb_500 )); then
            _node_memory="512"
        elif  (( _mem > _gb_300 )); then
            _node_memory=">300"
        elif (( _mem > _gb_250 && _mem < _gb_265 )); then
            _node_memory="256"
        elif (( _mem > _gb_180 && _mem < _gb_200 )); then
            _node_memory="192"
        elif (( _mem > _gb_120 )); then
            _node_memory="128"
        else
            _node_memory="<128"
            gsc_loga "CRITICAL ERROR: INSUFFICIENT NODE MEMORY: <128 GB (${_mem} kB)"
            ((_err++))
        fi

        gsc_loga "INFO: Node total memory: ${_node_memory}"
    fi
else
    gsc_loga "WARNING: using input node memory size: ${_node_memory}"
fi

if [[ "${_skip_parse}" == "false" ]]; then
    gsc_loga "INFO: Running: ${_tools_dir}/parse_services_memory.sh ${_services_memconfig_file} ${_services_parsed_memconfig_file}"
    "${_tools_dir}/parse_services_memory.sh" "${_services_memconfig_file}" "${_services_parsed_memconfig_file}" > /dev/null
    if [[ ! -f ${_services_parsed_memconfig_file} ]]; then
        gsc_loga "ERROR: parse_services_memory.sh FAILED TO GENERATE ${_services_parsed_memconfig_file} file."
        exit 1
    fi
else
    _services_parsed_memconfig_file=$(find "${_log_dir}" | grep -m 1 "${_services_parsed_memconfig_file_suffix}")
    gsc_loga "WARNING: skipping parsing. Using previously parsed file: ${_services_parsed_memconfig_file}"
fi

_is_file_empty=$(grep -c "Metadata-Gateway" "${_services_parsed_memconfig_file}")
if [[ "${_is_file_empty}" == "0" ]]; then
    gsc_loga "ERROR: health-check script failed to generate a proper memory config file: ${_services_parsed_memconfig_file}"
    exit 1
fi

# Load active/running service names from hcpcs_services_info.log
load_active_services

# Derive numeric GB value from _node_memory for profile selection
_node_mem_gb=$(echo "${_node_memory}" | tr -cd '0-9')
if [[ -z "${_node_mem_gb}" ]]; then
    _node_mem_gb=0
fi

_total_used_memory=0
while IFS= read -r _line; do
    # memcheck.conf line format:
    # ServiceName  128_min  128_max  256_min  256_max
    _service=$(echo "${_line}" | awk '{ print $1 }')

    # If service is not running (not in active list), skip it silently
    if ! is_service_active "${_service}"; then
        continue
    fi

    _raw_128_min=$(echo "${_line}" | awk '{ print $2 }')
    _raw_128_max=$(echo "${_line}" | awk '{ print $3 }')
    _raw_256_min=$(echo "${_line}" | awk '{ print $4 }')
    _raw_256_max=$(echo "${_line}" | awk '{ print $5 }')

    # Strip any non-digits from min/max values
    _mem_128_min=$(echo "${_raw_128_min}" | tr -cd '0-9')
    _mem_128_max=$(echo "${_raw_128_max}" | tr -cd '0-9')
    _mem_256_min=$(echo "${_raw_256_min}" | tr -cd '0-9')
    _mem_256_max=$(echo "${_raw_256_max}" | tr -cd '0-9')

    # Default if fields missing
    [[ -z "${_mem_128_min}" ]] && _mem_128_min=0
    [[ -z "${_mem_128_max}" ]] && _mem_128_max=0
    [[ -z "${_mem_256_min}" ]] && _mem_256_min=0
    [[ -z "${_mem_256_max}" ]] && _mem_256_max=0

    # Choose profile: >=192 GB -> 256 profile; else 128 profile
    _use_256_profile=false
    if (( _node_mem_gb >= 192 )); then
        _use_256_profile=true
    fi

    if [[ "${_use_256_profile}" == "true" && "${_mem_256_min}" != "0" && "${_mem_256_max}" != "0" ]]; then
        _min_mem="${_mem_256_min}"
        _max_mem="${_mem_256_max}"
    else
        # Fallback to 128 profile if 256 not defined or node <192 GB
        _min_mem="${_mem_128_min}"
        _max_mem="${_mem_128_max}"
    fi

    _current_service_line=$(grep "${_service}" "${_services_parsed_memconfig_file}")

    # If service not present in services file (but it is in active list), error
    if [[ -z "${_current_service_line}" ]]; then
        ((_err++))
        gsc_loga "ERROR: ${_service} - NOT FOUND in services memory config file ${_services_parsed_memconfig_file}"
        continue
    fi

    # Column 2: service memory (e.g. 2400m, 4096, 8192M, etc.)
    _raw_current_memory=$(echo "${_current_service_line}" | awk '{ print $2 }')
    # Column 3: heap (e.g. 1200m, 4096, etc.)
    _raw_current_heapsize=$(echo "${_current_service_line}" | awk '{ print $3 }')

    # Strip all non-digits from memory/heap values
    _current_memory=$(echo "${_raw_current_memory}" | tr -cd '0-9')
    _current_heapsize=$(echo "${_raw_current_heapsize}" | tr -cd '0-9')

    # Default to 0 if something came out empty
    [[ -z "${_current_memory}" ]] && _current_memory=0
    # heap may legitimately be empty for non-heap services

    # HEAP CHECK: heap should be approximately 1/2 of service memory when defined
    _current_heapsize_int=$(echo "${_current_heapsize}" | tr -cd '0-9')

    if [[ -n "${_current_heapsize_int}" && "${_current_heapsize_int}" != "0" ]]; then
        _expected_heap=$(( _current_memory / 2 ))

        # Allow ±10% tolerance around 1/2
        _lower_bound=$(( _expected_heap * 9 / 10 ))
        _upper_bound=$(( _expected_heap * 11 / 10 ))

        if (( _current_heapsize_int < _lower_bound || _current_heapsize_int > _upper_bound )); then
            ((_err++))
            ((_heap_mismatch_count++))
            gsc_loga "ERROR: ${_service} - HEAP SIZE MISMATCH: heap=${_current_heapsize_int} MB, memory=${_current_memory} MB, expected≈${_expected_heap} MB (½ of memory)"
        else
            ((_heap_ok_count++))
        fi
    else
        ((_heap_skipped_count++))
    fi

    ((_total_used_memory+=_current_memory))

    # Compare against selected min/max
    if (( _current_memory < _min_mem )); then
        ((_err++))
        gsc_loga "ERROR: ${_service} - INCREASE MEMORY SETTING: should be ${_min_mem} (current: ${_current_memory})"
    elif (( _current_memory > _max_mem )) ; then
        ((_err++))
        if (( _current_memory > _max_mem * 2 )); then
            gsc_loga "ERROR: ${_service} - UNNECESSARY LARGE MEMORY SETTING: ${_current_memory}, should be between ${_min_mem} and ${_max_mem}"
        else
            gsc_loga "WARNING: ${_service} - larger then needed memory settings: ${_current_memory}, should be between ${_min_mem} and ${_max_mem}"
        fi
    fi

    spinner

done < "${_mem_config_required_file}"

# OS, Docker and Foundry services need some memory too
# _node_memory can be "<128", "128", "192", "256", ">300"
_node_mem_text=$(echo "${_node_memory}" | tr -cd '0-9')
[[ -z "${_node_mem_text}" ]] && _node_mem_text=0

# Available memory for services after reserving _other_memory GB
((_available_memory=(_node_mem_text-_other_memory)*1024))
if (( _total_used_memory > _available_memory )); then
    ((_err++))
    gsc_loga "CRITICAL ERROR: INSUFFICIENT NODE MEMORY - TOTAL USED BY SERVICES: ${_total_used_memory} MB"
fi

# Baseline Tested Configuration Check: 256GB node - 30GB OS = 226GB (231424 MB)
_tested_limit_mb=$(( (256 - _other_memory) * 1024 ))
if (( _total_used_memory > _tested_limit_mb )); then
    gsc_loga "WARNING: Total service memory (${_total_used_memory} MB) exceeds the tested CS configuration limit (${_tested_limit_mb} MB)."
    gsc_log_action "Please open an ASPSUS JIRA to review and approve this high-memory configuration."
fi

# --- Summary: services vs OS memory ---

_node_total_mb=$((_node_mem_text * 1024))
if (( _node_total_mb < 0 )); then
    _node_total_mb=0
fi

_os_memory_mb=$((_node_total_mb - _total_used_memory))
if (( _os_memory_mb < 0 )); then
    _os_memory_mb=0
fi

_services_gb=$(( _total_used_memory / 1024 ))
_os_gb=$(( _os_memory_mb / 1024 ))

gsc_loga "INFO: TOTAL SERVICES MEMORY: ${_total_used_memory} MB (~${_services_gb} GB)"
gsc_loga "INFO: ESTIMATED OS/OTHER MEMORY: ${_os_memory_mb} MB (~${_os_gb} GB)"

gsc_loga "INFO: HEAP SUMMARY: ${_heap_ok_count} services OK, ${_heap_mismatch_count} mismatched, ${_heap_skipped_count} without heap configured"

if [[ "${_err}" == "0" ]]; then
    gsc_loga "INFO: No issues found in services memory configuration."
else
    gsc_loga "ERROR: detected ${_err} errors in services memory configuration."
fi

gsc_loga "INFO: Processed services memory config. Generated ${_output_file} file."
